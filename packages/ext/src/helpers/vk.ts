import type { VideoDataSubtitle } from "@vot.js/core/types/client";
import Logger from "@vot.js/shared/utils/logger";
import { buildVkVideoUrl, normalizeLang } from "@vot.js/shared/utils/utils";
import type { MinimalVideoData } from "../types/client";
import type * as VK from "../types/helpers/vk";
import { BaseHelper } from "./base";

declare global {
  const Videoview: VK.Videoview | undefined;
}

export default class VKHelper extends BaseHelper {
  static getPlayer() {
    if (typeof Videoview === "undefined") {
      return undefined;
    }

    try {
      return Videoview?.getPlayerObject?.();
    } catch {
      return undefined;
    }
  }

  // eslint-disable-next-line @typescript-eslint/require-await
  async getVideoData(videoId: string): Promise<MinimalVideoData | undefined> {
    const currentUrl = new URL(window.location.href);

    const player = VKHelper.getPlayer();
    if (!player) {
      const base = this.returnBaseData(videoId);
      return base
        ? { ...base, url: buildVkVideoUrl(videoId, currentUrl) }
        : base;
    }

    try {
      const {
        description: descriptionHTML,
        duration,
        md_title: title,
      } = player.vars;

      const parser = new DOMParser();
      const doc = parser.parseFromString(descriptionHTML, "text/html");
      const description = Array.from(doc.body.childNodes)
        .filter((el) => el.nodeName !== "BR")
        .map((el) => el.textContent)
        .join("\n");

      let subtitles: VideoDataSubtitle[] | undefined;
      if (Object.hasOwn(player.vars, "subs")) {
        subtitles = (player.vars as VK.PlayerVarsWithSubs).subs.map((sub) => ({
          language: normalizeLang(sub.lang),
          source: "vk",
          format: "vtt",
          url: sub.url,
          isAutoGenerated: !!sub.is_auto,
        }));
      }

      return {
        url: buildVkVideoUrl(videoId, currentUrl),
        title,
        description,
        duration,
        subtitles,
      };
    } catch (err) {
      Logger.error(
        `Failed to get VK video data, because: ${(err as Error).message}`,
      );
      const base = this.returnBaseData(videoId);
      return base
        ? { ...base, url: buildVkVideoUrl(videoId, currentUrl) }
        : base;
    }
  }

  // eslint-disable-next-line @typescript-eslint/require-await
  async getVideoId(url: URL) {
    const pathID = /^\/((?:video|clip)-?\d+_\d+)(?:\/)?$/.exec(url.pathname);
    if (pathID) {
      return pathID[1];
    }

    const idInsidePlaylist = /\/playlist\/[^/]+\/(video-?\d+_\d+)/.exec(
      url.pathname,
    );
    if (idInsidePlaylist) {
      return idInsidePlaylist[1];
    }

    const paramZ = url.searchParams.get("z");
    if (paramZ) {
      return paramZ.split("/")[0];
    }

    const paramOID = url.searchParams.get("oid");
    const paramID = url.searchParams.get("id");
    if (paramOID && paramID) {
      const ownerId = Math.abs(Number.parseInt(paramOID, 10));
      if (!Number.isNaN(ownerId)) {
        return `video-${ownerId}_${paramID}`;
      }
    }

    return undefined;
  }
}
